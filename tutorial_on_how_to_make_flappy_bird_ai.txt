
Search
Write
Sign up

Sign in



How I Built an Intelligent Agent to Play Flappy Bird
Danny Zhu
Analytics Vidhya
Danny Zhu

·
Follow

Published in
Analytics Vidhya

·
15 min read
·
May 20, 2020
170


2



An intelligent agent playing Flappy Bird
An Intelligent Agent Playing Flappy Bird
Introduction
Have you ever played Flappy Bird? In this animation, you are looking at a skilled player playing the game Flappy Bird. However, this player is not a human being. It is an Intelligence Agent (IA) I built using the NeuroEvolution of Augmenting Topologies (NEAT) algorithm.

In September 2019, an article released by OpenAI called Emergent Tool Use from Multi-Agent Interaction demonstrated how agents learn to use sophisticated tools and strategies progressively in a simulated hide-and-seek environment. I found it particularly interesting and would like to learn more about Reinforcement Learning (RL).



Multi-Agent Hide and Seek. Source: Emergent Tool Use from Multi-Agent Interaction by OpenAI
During my study, I came across a paper by Uber AI Labs titled Deep Neuroevolution: Genetic Algorithms Are a Competitive Alternative for Training Deep Neural Networks for Reinforcement Learning, where researchers presented empirical evidence that a simple Genetic Algorithm (GA) can perform amazingly well for RL problems. Besides the hide-and-seek example we saw above, RL has been successfully applied to various games such as Atari, Snake, and Dino Run. What if we could build a game IA using GA instead? This thought triggered my keen interest in building a Flappy Bird IA using NEAT, a GA developed by Ken Stanley in 2002.




Teach AI to Play Games Using Reinforcement Learning. Source: Atari, Snake, and Dino Run.
Why Flappy Bird?
For those who are not familiar with the game Flappy Bird, it is a popular mobile game developed by Dong Nguyen in 2013. Flappy Bird received a massive influx of players and achieved great success in a short period. Players tap the screen to navigate the bird, which has to jump at the right moment to get through a set of Mario-like pipes.


Flappy Bird. Source: flappybird.io
Flappy Bird is a reasonable choice for beginners interested in building a game from scratch, because the game’s mechanism is straightforward and the only gameplay action is to jump. Also, creating an IA won’t be too complicated, since we just need a few inputs to get a binary output (I will talk about it later). Last but not least, Flappy Bird is one of my favorite mobile games ever! So, when it comes to building my first game, Flappy Bird is a no-brainer.

How to build Flappy Bird in Python?
The main module that I used is Pygame. There are tons of tutorials available online, and here are some of my favorites:

A Newbie Guide to Pygame
PyGame Tutorials: Simple Introduction to Game Programming
YouTube Playlist for PyGame Tutorials by thenewboston
In terms of building Flappy Bird in Pygame, there are also a lot of tutorials. Here is a list of tutorials that I found very useful. I took notes from them, summarized their methods, and tried to build my code on top of theirs. Please check them out if you would like to learn more about this.

AI Plays Flappy Bird Using NEAT Python by Tech with Tim
Neural nets with Flappy and Pygame by Bluefever Software
Flappy Bird Python Tutorials For Absolute Beginners by CodeWithHarry
Before coding, I always draw a mind map to guide me through the process. Here is the demonstration of the mind map:


An Example of Mind Map for Building Flappy Bird
To make Flappy Bird, we need three Python objects: the bird, the pipe, and the floor. We also need a few functions to check collision, display, and run the game. Like most games, the game options section allows us to alter some game features according to our preference.

Now, let’s dive into code!



#import packages to build the game
from __future__ import print_function
import pygame
import time
import os
import random

#initialize pygame
pygame.init()

#set up the screen to display the game
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 550
SCREEN = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

#set up the font
FONT = pygame.font.SysFont('comicsansms', 20)
FONT_COLOR = (255, 255, 255) #white font

#load the required images
BIRD_IMGS = [pygame.image.load('Flappy Bird.png'),
             pygame.image.load('Flappy Bird Wings Up.png'),
             pygame.image.load('Flappy Bird Wings Down.png')]
BOTTOM_PIPE_IMG = pygame.image.load('Super Mario pipe.png')
TOP_PIPE_IMG = pygame.transform.flip(BOTTOM_PIPE_IMG, False, True) #flip the image of the bottom pipe to get the image for the pipe on the top
FLOOR_IMG = pygame.image.load('Stone Floor.png')
BG_IMG = pygame.transform.scale(pygame.image.load('City Skyline.png'), (SCREEN_WIDTH, SCREEN_HEIGHT))
view rawPygame Initialization.py hosted with ❤ by GitHub

First of all, import packages, initialize Pygame, and set up the screen to display the game.


Game Initialization
Here are some game options that will be used later.


#set the game options
FPS = 30 #run the game at rate FPS, the speed at which images are shown
max_score = 100 #the maximum score of the game before we break the loop

#floor options
floor_velocity = 5 #the horizontal moving velocity of the floor, this should equal to pipe_velocity
floor_starting_y_position = 500 #the starting y position of the floor

#pipe options
pipe_max_num = 100 #the maximum number of pipes in this game
pipe_vertical_gap = 150 #the gap between the top pipe and the bottom pipe, the smaller the number, the harder the game
pipe_horizontal_gap = 200 #the gap between two sets of pipes
pipe_velocity = 5 #the horizontal moving velocity of the pipes, this should equal to floor_velocity
top_pipe_min_height = 100 #the minimum height of the top pipe (carefully set this number)
top_pipe_max_height = 300 #the maximum height of the top pipe (carefully set this number)
pipe_starting_x_position = 500 #the starting x position of the first pipe

#bird options
bird_max_upward_angle = 35 #the maximum upward angle when flying up
bird_max_downward_angle = -90 #the maximum downward angle when flying down
bird_min_incremental_angle = 5 #the minimum incremental angle when tilting up or down
bird_angular_acceleration = 0.3 #the acceleration of bird's flying angle
bird_jump_velocity = -8 #the vertical jump up velocity
bird_acceleration = 3 #the gravity for the bird in the game
bird_max_displacement = 12 #the maximum displacement per frame
bird_starting_x_position = 150 #the starting x position of the bird
bird_starting_y_position = 250 #the starting y position of the bird
view rawGame Parameters Setting.py hosted with ❤ by GitHub

Game Parameters Setting

Flappy Bird Game Design
How to build a bird?
We need a few class methods to mimic the movement. Recall what we learned in our middle school Physics classes, the equation to calculate the displacement d of a body that starts with a non-zero speed v from time 0 to time t is: d = vt + 1/2at², where a is the acceleration. If the bird jumps, it obtains an upward velocity. Then we update the bird’s position according to the displacement calculation.


#build the class Bird
class Bird:
    #Bird's attributes
    IMGS = BIRD_IMGS
    MAX_UPWARD_ANGLE = bird_max_upward_angle
    MAX_DOWNWARD_ANGLE = bird_max_downward_angle
    
    #initialize the Object
    def __init__(self, x_position, y_position):
        self.bird_img = self.IMGS[0] #use the first image as the initial image
        self.x = x_position #starting x position
        self.y = y_position #starting y position
        self.fly_angle = 0 #starting flying angle, initialized to be 0
        self.time = 0 #starting time set to calculate displacement, initialized to be 0
        self.velocity = 0 #starting vertical velocity, initialized to be 0
        self.index = 0 #used to change bird images, initialized to be 0
        
    #defien a function to move the bird
    def move(self):
        self.time += 1 #count the time
        
        #for a body with a nonzero speed v and a constant acceleration a
        #the displacement d of this body after time t is d = vt + 1/2at^2
        displacement = self.velocity * self.time + (1/2) * bird_acceleration * self.time ** 2 #calculate the displacement when going downward
        
        #we don't want the bird going donw too fast
        #so we need to set a displacement limit per frame
        if displacement > bird_max_displacement:
            displacement = bird_max_displacement
        
        self.y = self.y + displacement #update the bird y position after the displacement
        
        if displacement < 0: #when the bird is going up
            if self.fly_angle < self.MAX_UPWARD_ANGLE: #if the flying angle is less than the maximum upward angle
                self.fly_angle += max(bird_angular_acceleration*(self.MAX_UPWARD_ANGLE - self.fly_angle), bird_min_incremental_angle) #accelerate the angle up
            elif self.fly_angle >= self.MAX_UPWARD_ANGLE:
                self.fly_angle = self.MAX_UPWARD_ANGLE
                
        else: #when the bird is going down
            if self.fly_angle > self.MAX_DOWNWARD_ANGLE: #if the flying angle is less than the maximum downward angle
                self.fly_angle -= abs(min(bird_angular_acceleration*(self.MAX_DOWNWARD_ANGLE - self.fly_angle), -bird_min_incremental_angle)) #accelerate the angle down
            elif self.fly_angle <= self.MAX_DOWNWARD_ANGLE:
                self.fly_angle = self.MAX_DOWNWARD_ANGLE

    #defien a function to jump the bird
    def jump(self):
        self.velocity = bird_jump_velocity #jump up by bird_jump_velocity
        self.time = 0 #when we jump, we reset the time to 0
    
    #define a function to get the rotated image and rotated rectangle for draw function
    def update(self):
        #if the bird is diving, then it shouldn't flap its wings        
        if self.fly_angle < -45:
            self.bird_img = self.IMGS[0]
            self.index = 0 #reset the index
        
        #if the bird is not diving, then it should flap its wings
        #keep looping the 3 bird images to mimic flapping its wings
        elif self.index >= len(self.IMGS):
            self.index = 0
        
        self.bird_img = self.IMGS[self.index]
        self.index += 1
        
        #https://stackoverflow.com/questions/4183208/how-do-i-rotate-an-image-around-its-center-using-pygame
        #rotate the bird image for degree at self.tilt
        rotated_image = pygame.transform.rotate(self.bird_img, self.fly_angle)
        #store the center of the source image rectangle
        origin_img_center = self.bird_img.get_rect(topleft = (self.x, self.y)).center
        #update the center of the rotated image rectangle
        rotated_rect = rotated_image.get_rect(center = origin_img_center)
        #get the rotated bird image and the rotated rectangle
        return rotated_image, rotated_rect
view rawBuild A Bird.py hosted with ❤ by GitHub

Build A Bird
How to build a pipe?
The pipe is more straightforward than the bird. Pipes move horizontally with a fixed velocity. A simple move method is shown below. Another class method we need is to randomize the position of pipe gaps. Because the size of each gap is the same, we can simply randomize the height of the top pipe, and then the height of the bottom pipe will change accordingly.


#build the class Pipe
class Pipe:
    #Pipe's attributes
    VERTICAL_GAP = pipe_vertical_gap #the gap between the top and bottom pipes
    VELOCITY = pipe_velocity #the moving velocity of the pipes
    IMG_WIDTH = TOP_PIPE_IMG.get_width() #the width of the pipe
    IMG_LENGTH = TOP_PIPE_IMG.get_height() #the length of the pipe

    #initialize the Object
    def __init__(self, x_position):                
        self.top_pipe_img = TOP_PIPE_IMG #get the image for the pipe on the top
        self.bottom_pipe_img = BOTTOM_PIPE_IMG #get the image for the pipe on the bottom
        self.x = x_position #starting x position of the first set of pipes
        self.top_pipe_height = 0 #the height of the top pipe, initialized to be 0
        self.top_pipe_topleft = 0 #the topleft position of the top pipe, initialized to be 0
        self.bottom_pipe_topleft = 0 #the topleft position of the bottom pipe, initialized to be 0
        self.random_height() #set the height of the pipes randomly as well as the starting topleft position for top and bottom pipes
        
    #define a function to move the pipe
    def move(self):
        self.x -= self.VELOCITY
    
    #define a function to randomize pipe gaps
    def random_height(self):
        self.top_pipe_height = random.randrange(top_pipe_min_height, top_pipe_max_height) #the range is between top_pipe_min_height and top_pipe_max_height
        self.top_pipe_topleft = self.top_pipe_height - self.IMG_LENGTH #the topleft position of the top pipe should be the random height - the length of the pipe
        self.bottom_pipe_topleft = self.top_pipe_height + self.VERTICAL_GAP #the topleft position of the bottom pipe should be the random height + the GAP
view rawBuild A Pipe.py hosted with ❤ by GitHub

Build A Pipe
How to build a floor?
The floor is the simplest one. It moves horizontally with a fixed velocity. We can duplicate three images and tie them together. Once the first image moves out of the screen, we append it to the right of the last image. The same applies to the second and the third image.


#build the class Floor
class Floor:
    #Floor's attributes
    IMGS = [FLOOR_IMG, FLOOR_IMG, FLOOR_IMG] #we need 3 floor images to set up the moving floor
    VELOCITY = floor_velocity #the moving velocity of the floor
    IMG_WIDTH = FLOOR_IMG.get_width() #the width of the floor

    #initialize the Object
    def __init__(self, y_position):
        #these 3 images have different starting position but have the same y position
        self.x1 = 0 #the starting x position of the first floor image
        self.x2 = self.IMG_WIDTH #the starting x position of the second floor image
        self.x3 = self.IMG_WIDTH * 2 #the starting x position of the third floor image
        self.y = y_position #the y position of the floor image
        
    #define a function to move the floor
    def move(self):
        self.x1 -= self.VELOCITY #move to the left with the velocity of VELOCITY
        self.x2 -= self.VELOCITY #move to the left with the velocity of VELOCITY
        self.x3 -= self.VELOCITY #move to the left with the velocity of VELOCITY
        
        if self.x1 + self.IMG_WIDTH < 0: #if the first floor image moves out of the screen 
            self.x1 = self.x3 + self.IMG_WIDTH #then move the first floor image to to the right of the third floor image
        if self.x2 + self.IMG_WIDTH < 0: #if the second floor image moves out of the screen 
            self.x2 = self.x1 + self.IMG_WIDTH #then move the second floor image to to the right of the first floor image
        if self.x3 + self.IMG_WIDTH < 0: #if the third floor image moves out of the screen 
            self.x3 = self.x2 + self.IMG_WIDTH #then move the third floor image to to the right of the second floor image
view rawBuild A Floor.py hosted with ❤ by GitHub

Build A Floor
How to check collision?


Rectangle Collision Detection (left) vs Pixel Perfect Collision detection (right)
If the image of a bird overlaps with the image of a pipe, then we say the bird hits the pipe. There are mainly two ways to check overlap. One is called Rectangle Collision Detection by pygame.Rect.colliderect function. The other is called Pixel Perfect Collision Detection by pygame.mask.Mask.overlap function. Note that we also say the bird collides if it hit the upper limit or the ground.


#define a function to check collision
def collide(bird, pipe, floor, screen):
    
    #Creates a Mask object from the given surface by setting all the opaque pixels and not setting the transparent pixels
    bird_mask = pygame.mask.from_surface(bird.bird_img) #get the mask of the bird
    top_pipe_mask = pygame.mask.from_surface(pipe.top_pipe_img) #get the mask of the pipe on the top
    bottom_pipe_mask = pygame.mask.from_surface(pipe.bottom_pipe_img) #get the mask of the pipe on the bottom
    
    sky_height = 0 #the sky height is the upper limit
    floor_height = floor.y #the floor height is the lower limit
    bird_lower_end = bird.y + bird.bird_img.get_height() #the y position of the lower end of the bird image
    
    #in order to check whether the bird hit the pipe, we need to find the point of intersection of the bird and the pipes
    #if overlap, then mask.overlap(othermask, offset) return (x, y)
    #if not overlap, then mask.overlap(othermask, offset) return None
    #more information regarding offset, https://www.pygame.org/docs/ref/mask.html#mask-offset-label
    top_pipe_offset = (round(pipe.x - bird.x), round(pipe.top_pipe_topleft - bird.y))
    bottom_pipe_offset = (round(pipe.x - bird.x), round(pipe.bottom_pipe_topleft - bird.y))
    
    #Returns the first point of intersection encountered between bird's mask and pipe's masks
    top_pipe_intersection_point = bird_mask.overlap(top_pipe_mask, top_pipe_offset)
    bottom_pipe_intersection_point = bird_mask.overlap(bottom_pipe_mask, bottom_pipe_offset)

    if top_pipe_intersection_point is not None or bottom_pipe_intersection_point is not None or bird_lower_end > floor_height or bird.y < sky_height:
        return True
    else:
        return False
view rawCheck Collision.py hosted with ❤ by GitHub

Check Collision
How to display the game?
Here is the function to display the game. We draw a background, a moving floor, a set of pipes, and a flock of birds. We also add a few text messages to show some additional information.


#define a function to draw the screen to display the game
def draw_game(screen, birds, pipes, floor, score, generation, game_time):
    
    #draw the background
    screen.blit(BG_IMG, (0, 0))
    
    #draw the moving floor
    screen.blit(floor.IMGS[0], (floor.x1, floor.y)) #draw the first floor image
    screen.blit(floor.IMGS[1], (floor.x2, floor.y)) #draw the second floor image
    screen.blit(floor.IMGS[2], (floor.x3, floor.y)) #draw the third floor image
    
    #draw the moving pipes
    for pipe in pipes:
        screen.blit(pipe.top_pipe_img, (pipe.x, pipe.top_pipe_topleft)) #draw the pipe on the top
        screen.blit(pipe.bottom_pipe_img, (pipe.x, pipe.bottom_pipe_topleft)) #draw the pipe on the bottom
    
    #draw the animated birds
    for bird in birds:
        rotated_image, rotated_rect = bird.update()
        screen.blit(rotated_image, rotated_rect)
    
    #add additional information
    score_text = FONT.render('Score: ' + str(score), 1, FONT_COLOR) #set up the text to show the scores
    screen.blit(score_text, (SCREEN_WIDTH - 15 - score_text.get_width(), 15)) #draw the scores
    
    game_time_text = FONT.render('Timer: ' + str(game_time) + ' s', 1, FONT_COLOR) #set up the text to show the progress
    screen.blit(game_time_text, (SCREEN_WIDTH - 15 - game_time_text.get_width(), 15 + score_text.get_height())) #draw the progress
    
    generation_text = FONT.render('Generation: ' + str(generation - 1), 1, FONT_COLOR) #set up the text to show the number of generation
    screen.blit(generation_text, (15, 15)) #draw the generation
    
    bird_text = FONT.render('Birds Alive: ' + str(len(birds)), 1, FONT_COLOR) #set up the text to show the number of birds alive
    screen.blit(bird_text, (15, 15 + generation_text.get_height())) #draw the number of birds alive
    
    progress_text = FONT.render('Pipes Remained: ' + str(len(pipes) - score), 1, FONT_COLOR) #set up the text to show the progress
    screen.blit(progress_text, (15, 15 + generation_text.get_height() + bird_text.get_height())) #draw the progress
    
    pygame.display.update() #show the surface
view rawDraw Game Screen.py hosted with ❤ by GitHub

Draw Game Screen
Now the game is almost done, let’s see how to build an IA.

NeuroEvolution of Augmenting Topologies (NEAT)

NeuroEvolution of Augmenting Topologies. Source: Evolv Technologies
NEAT stands for NeuroEvolution of Augmenting Topologies, which is a genetic algorithm designed to efficiently evolve artificial neural network topologies. It’s an awesome technique that addressed some challenges of Topology and Weight Evolving Artiﬁcial Neural Networks (TWEANN). Before we go deeper into NEAT, let’s take a look at two key concepts: Artificial Neural Network (ANN) and Genetic Algorithm (GA).

What is an artificial neural network?

A Typical Artificial Neural Network Architecture
An artificial neural network (ANN) is a brain-inspired computing system that consists of interconnected nodes and weighted connections. A typical ANN architecture contains an input layer, some hidden layers, and an output layer. Each node in the hidden layer and the output layer consists of an activation function that transforms the weighted sum of input values to output. In most cases, an ANN can learn by properly adjusting its connection weights through backpropagation, a technique that performs gradient methods to minimize loss.

If you would like to learn more about ANN, here are some resources that may be helpful:

Wikipedia: Artificial Neural Network
Introduction to Artificial Neural Networks(ANN)
YouTube Playlist for Neural Networks Tutorials by 3Blue1Brown
What is a genetic algorithm?
“We see beautiful adaptation everywhere and in every part of the organic world.” — Charles Darwin, On the Origin of Species.

In 1859, a theory of natural selection introduced by Charles Darwin lay the first stone of evolutionary biology. The essence of this theory is that those most adaptable to change are most likely to survive. Since then, the notion of “Survival of the Fittest” provided a new way for people to understand species evolution.


Darwin’s finches by Gould. Source: Wikimedia
If biological evolution is able to generate amazing species like human beings and many others, is it possible to combine modern genetics with machine learning techniques to solve a problem? Genetic algorithms open the door of opportunity and shine the way to possibilities.


Genetic Algorithm. Source: NewScientist
By definition, a genetic algorithm is a heuristic technique that simulates the process of natural selection to solve a vast variety of optimization problems, especially those with a nondifferentiable or stochastic objective function.

Here are some of the key terms:

Fitness function: In many cases, a fitness function is the same as an objective function. It is a function that takes the solution as input and generates a fitness score as output to evaluate the quality of each solution. It is an essential element of a GA. We should tailor the fitness function based on each specific problem.
Population: In GA, the population is the subset of all the candidate solutions to a given problem.
Chromosome: Each candidate solution in the population is a chromosome, sometimes referred to as a genome.
Gene: Each element position within a chromosome is a gene, which has a specific value and determines the genotype and the phenotype of the solution.
Generation: At each iteration, GA performs a set of genetic operators (selection, crossover, mutation, etc.) on the current population to generate a successive generation.
Selection: Selection is the process of filtering and retaining solutions according to fitness score. Solutions with higher fitness are more likely to be pushed forward into the next generation. A pair of selected solutions could be chosen as parents to breed and propagate their genes to the subsequent generation via crossover.
Crossover: Crossover is the way parent chromosomes produce child chromosomes. Genes of parents are reassembled based on a set of crossover points to formulate new offspring.
Mutation: Mutation in GA is a small random tweak of the genes in chromosomes. It allows GA to explore the solution space and avoid falling into local minima.
Here is a demonstration of how a typical GA works:


A Typical Genetic Algorithm Workflow
In the beginning, we randomly generate N solutions as our initiated population. We then move on to the evaluation stage, where we assign tasks and calculate the fitness score for each solution. Next, we determine whether to terminate the literation based on the following conditions: Did we obtain an acceptable solution? Did we reach the time or generation limit? Are we stuck in the performance stagnation? If no, we will proceed and conduct genetic operators to reproduce offspring for the next generation.

To help illustrate the workflow, here is the “Hello World” problem for GA, the Knapsack Problem.


Knapsack Problem. Source: Wikipedia
Imagine that you are given five items with different weights and values. You want to maximize the total value of the items included in your bag. However, your capacity is 15 kg. The optimal collection in this example may seem intuitive to you, but let’s see how a GA approaches this problem.


An Example of GA Workflow for Knapsack Problem
In this case, we define the fitness function as the summation of the value of each item included in our bag. In other words, we believe a collection is better if its total value is higher. Besides, the total weight should not exceed our capacity. At the beginning of the iteration, we randomly generate four solutions (population) as our first generation. For each solution (chromosome), we denote whether an item is included (“1”) or not included (“0'), representing a gene. Each proposed solution has a fitness score. The top-scored solutions are more likely to be chosen as parents (selection). The two selected chromosomes exchange some of their genes based on crossover points (crossover). Moreover, there is a small probability that some genes of the new offspring will change (mutation). Finally, a new generation is born. The loop will continue until termination requirements are met.

Now that we have some basic knowledge of ANN and GA, let’s dive into NEAT!

What is the NeuroEvolution of Augmenting Topologies?
In short, NEAT is a GA designed to evolve ANN. One big question you may have is what makes NEAT special? I believe the answer to this question can be found in this brilliant 6-page paper written by Kenneth Stanley in 2002. The following discussion is based on this original paper.

The process of evolving an ANN using GA instead of backpropagation is also known as Neuroevolution (NE). The beauty of NEAT is that it renders solutions to tackle three main challenges for NE:

Is there a genetic representation that allows disparate topologies to crossover in a meaningful way?
How can topological innovation that needs a few generations to optimize be protected so that it does not disappear from the population prematurely?
How can topologies be minimized throughout evolution without the need for a specially contrived ﬁtness function that measures complexity?
Here are the key concepts that underpin NEAT:

Genetic Encoding: Genetic encoding is the process of representing the chromosomes in a GA. NEAT uses a direct encoding scheme that each genome consists of a list of node genes and a list of connection genes. Node genes indicate all the input, hidden, and output nodes that can be connected, while connection genes store the connection information and an innovation number for historical markings. By doing so, NEAT can line up the corresponding genes quickly during the crossover process.

An Example of Genetic Encoding in NEAT. Source: Efficient Evolution of Neural Network Topologies
Growth: NEAT grows and evolves the topology by structural mutation. Mutation can be adding a new node in an old connection or adding a new connection between two unconnected nodes. Therefore, NEAT is able to improve genome diversity, explore solution space, and avoid local minima.

An Example of Growth in NEAT. Source: Efficient Evolution of Neural Network Topologies
Historical Markings: Historical markings is the process of tracking genes. NEAT uses a global innovation number that represents a chronology of a gene in the system to perform historical markings. A new innovation number will be assigned to that gene whenever a new node or connection is created. During crossover, the offspring randomly choose genes with the same innovation number (matching genes) from either parent and inherit those with different innovation number (disjoint or excess genes) from the more ﬁt parent. Accordingly, NEAT ensures the crossover is meaningful and resolves competing convention, a situation that parents with a similar phenotype produce damaged offspring.

An Example of Historical Markings in NEAT. Source: Efficient Evolution of Neural Network Topologies
Speciation: A topological innovation usually comes with reduced fitness and requires time to optimize its performance. However, if competing with the overall population directly, a new topology is likely to be eliminated before it reaches its best fitness. This is why speciation plays a critical role in NEAT. NEAT measures a compatibility distance between two genomes. Compatibility is calculated by a linear combination of the average weight differences of matching genes and the number of excess and disjoin genes. Genomes are clustered into different species based on a compatibility threshold. By doing so, each genome competes with those within the same niche. Therefore, a new species will be protected.

An Equation for Compatibility Distance. Source: Efficient Evolution of Neural Network Topologies
Minimizing Dimensionality: NEAT always begins with a uniform population and without any hidden nodes. A new structure is introduced by structural mutation and protected by speciation. Then fitness evaluation determines whether the innovation is useful. So, NEAT increases the complexity only when needed and thus decreases training time.
Here is an overview of the dependencies among these important components of NEAT:


Dependencies among NEAT Components. Source: Efficient Evolution of Neural Network Topologies
To sum up, NEAT (1) utilizes historical markings to tack genes and avoid competing conventions, so that a meaningful crossover could happen and less topological analysis is required; (2) separates the population into species based on compatibility distance, so that competition is primarily within the same niche and innovation is protected; (3) starts from the simplest structure and grows only as necessary through mutation, so that it’s faster to find a solution.

Now we know how NEAT works, let’s see how to use it.

How to apply NEAT to Flappy Bird?
It’s fairly simple to implement NEAT in Python, because there is a well-developed NEAT module that we can install by pip install neat-python. The documentation of this module clearly explained how to run NEAT in Python. So, check it out!

First, set up some parameters that will be used later.


#NEAT options
generation = 0 #note that the first generation of the birds is 0 because index starts from zero. XD
max_gen = 50 #the maximum number of generation to run
prob_threshold_to_jump = 0.8 #the probability threshold to activate the bird to jump
failed_punishment = 10 #the amount of fitness decrease after collision
view rawNEAT Parameters Setting.py hosted with ❤ by GitHub

NEAT Parameters Setting
We also need a configuration file for NEAT. You can find more explanation here.

Here are a few important parameters in the configuration file:

fitness_threshold: A parameter used to check whether we obtain an acceptable solution. The evolution process will terminate if the calculated fitness meets or exceeds this threshold.
pop_size: the number of genomes in each iteration.
survival_threshold: for each species, the percentage of genomes allowed to be selected for reproduction.
activation_default: the activation function assigned to each new node.
conn_add_prob: In mutation, the probability of adding a new connection.
node_add_prob: In mutation, the probability of adding a new node.
My configuration file for this project is shown below.


#here is an example of the configuration file setting for Flappy Bird
[NEAT]
fitness_criterion     = max
fitness_threshold     = 200
pop_size              = 5
reset_on_extinction   = True

[DefaultStagnation]
species_fitness_func = max
max_stagnation       = 15
species_elitism      = 1

[DefaultReproduction]
elitism            = 1
survival_threshold = 0.2
min_species_size   = 2

[DefaultGenome]
# node activation options
activation_default      = tanh
activation_mutate_rate  = 0.1
activation_options      = sigmoid

# node aggregation options
aggregation_default     = sum
aggregation_mutate_rate = 0.0
aggregation_options     = sum

# node bias options
bias_init_mean          = 0.0
bias_init_stdev         = 1.0
bias_init_type          = normal
bias_max_value          = 30.0
bias_min_value          = -30.0
bias_mutate_power       = 1.0
bias_mutate_rate        = 0.5
bias_replace_rate       = 0.1

# genome compatibility options
compatibility_disjoint_coefficient = 1.0
compatibility_weight_coefficient   = 0.5

# connection add/remove rates
conn_add_prob           = 0.5
conn_delete_prob        = 0.5

# connection enable options
enabled_default         = True
enabled_mutate_rate     = 0.01

feed_forward            = True
initial_connection      = full

# node add/remove rates
node_add_prob           = 0.2
node_delete_prob        = 0.2

# network parameters
num_hidden              = 0
num_inputs              = 3
num_outputs             = 1

# node response options
response_init_mean      = 1.0
response_init_stdev     = 0.0
response_init_type      = normal
response_max_value      = 30.0
response_min_value      = -30.0
response_mutate_power   = 1
response_mutate_rate    = 0.5
response_replace_rate   = 0.1

single_structural_mutation = False
structural_mutation_surer  = default

# connection weight options
weight_init_mean        = 0.0
weight_init_stdev       = 1.0
weight_max_value        = 30
weight_min_value        = -30
weight_mutate_power     = 1
weight_mutate_rate      = 0.5
weight_replace_rate     = 0.1

[DefaultSpeciesSet]
compatibility_threshold = 3.0
view rawconfig-feedforward.txt hosted with ❤ by GitHub

NEAT Configuration File
The fitness function is the combination of the game score, the alive time, and a collision punishment.

For each frame, the inputs of the models are:

delta_x: the horizontal distance between the bird and the pipe
delta_y_top: the vertical distance between the bird and the top pipe
delta_y_bottom: the vertical distance between the bird and the bottom pipe.
The output is whether to jump or not.


A Demonstration of Inputs and Output
Note that all the input information comes from the upcoming pipe, so we need a function to get the index of the closest pipe in our pipe list.


#define a function to get the input index of the pipes
def get_index(pipes, birds):
    #get the birds' x position
    bird_x = birds[0].x
    #calculate the x distance between birds and each pipes
    list_distance = [pipe.x + pipe.IMG_WIDTH - bird_x for pipe in pipes]
    #get the index of the pipe that has the minimum non negative distance(the closest pipe in front of the bird)
    index = list_distance.index(min(i for i in list_distance if i >= 0)) 
    return index
view rawGet Input Index.py hosted with ❤ by GitHub

Get Input Index
We also need a few functions for visualization. You can check an example here.

Then, we integrate NEAT into the game loop. The game runs by looping. Each loop is one frame. In each frame, we move the three objects we created, jump the bird if needed, check collision, and calculate the game score. The game will update according to game inputs and game logic.


#import packages to build the AI
import neat

#define a function to run the main game loop
def main(genomes, config):
    
    global generation, SCREEN #use the global variable gen and SCREEN
    screen = SCREEN
    generation += 1 #update the generation
    
    score = 0 #initiate score to 0
    clock = pygame.time.Clock() #set up a clock object to help control the game framerate
    start_time = pygame.time.get_ticks() #reset the start_time after every time we update our generation
    
    floor = Floor(floor_starting_y_position) #build the floor
    pipes_list = [Pipe(pipe_starting_x_position + i * pipe_horizontal_gap) for i in range(pipe_max_num)] #build the pipes and seperate them by pipe_horizontal_gap
    
    models_list = [] #create an empty list to store all the training neural networks
    genomes_list = [] #create an empty list to store all the training genomes
    birds_list = [] #create an empty list to store all the training birds
    
    for genome_id, genome in genomes: #for each genome
        birds_list.append(Bird(bird_starting_x_position, bird_starting_y_position)) #create a bird and append the bird in the list
        genome.fitness = 0 #start with fitness of 0
        genomes_list.append(genome) #append the genome in the list
        model = neat.nn.FeedForwardNetwork.create(genome, config) #set up the neural network for each genome using the configuration we set
        models_list.append(model) #append the neural network in the list
        
    run = True
    
    while run is True: #when we run the program
        
        #check the event of the game and quit if we close the window
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()
                quit()
                break
        
        #stop the game when the score exceed the maximum score
        #break the loop and restart when no bird left
        if score >= max_score or len(birds_list) == 0:
            run = False
            break
        
        game_time = round((pygame.time.get_ticks() - start_time)/1000, 2) #record the game time for this generation
        
        clock.tick(FPS) #update the clock, run at FPS frames per second (FPS). This can be used to help limit the runtime speed of a game.
        
        floor.move() #move the floor
        
        pipe_input_index = get_index(pipes_list, birds_list) #get the input index of the pipes list
        
        passed_pipes = [] #create an empty list to hold all the passed pipes
        for pipe in pipes_list:
            pipe.move() #move the pipe
            if pipe.x + pipe.IMG_WIDTH < birds_list[0].x: #if the bird passed the pipe
                passed_pipes.append(pipe) #append the pipe to the passed pipes list
                       
        score = len(passed_pipes) #calculate the score of the game, which equals to the number of pipes the bird passed
        
        for index, bird in enumerate(birds_list):
            bird.move() #move the bird
            delta_x = bird.x - pipes_list[pipe_input_index].x #input 1: the horizontal distance between the bird and the pipe
            delta_y_top = bird.y - pipes_list[pipe_input_index].top_pipe_height #input 2: the vertical distance between the bird and the top pipe
            delta_y_bottom = bird.y - pipes_list[pipe_input_index].bottom_pipe_topleft #input 3: the vertical distance between the bird and the bottom pipe
            net_input = (delta_x, delta_y_top, delta_y_bottom)
            #input the bird's distance from the pipes to get the output of whether to jump or not
            output = models_list[index].activate(net_input)
            
            if output[0] > prob_threshold_to_jump: #if the model output is greater than the probability threshold to jump
                bird.jump() #then jump the bird
            
            bird_failed = True if collide(bird, pipes_list[pipe_input_index], floor, screen) is True else False
            
            #the fitness function is a combination of game score, alive time, and a punishment for collision
            genomes_list[index].fitness = game_time + score - bird_failed * failed_punishment
            
            if bird_failed:
                models_list.pop(index) #drop the model from the list if collided
                genomes_list.pop(index) #drop the genome from the list if collided
                birds_list.pop(index) #drop the bird from the list if collided

        draw_game(screen, birds_list, pipes_list, floor, score, generation, game_time) #draw the screen of the game
view rawMain Game Loop.py hosted with ❤ by GitHub

Main Game Loop
Finally, we show learning progress in the terminal, visualize it, and check the statistics of the best model.


#define a function to run NEAT algorithm to play flappy bird
def run_NEAT(config_file):
    
    #the template for the configuration file can be found here:
    #https://github.com/CodeReclaimers/neat-python/blob/master/examples/xor/config-feedforward
    #the description of the options in the configuration file can be found here:
    #https://neat-python.readthedocs.io/en/latest/config_file.html#defaultgenome-section
    
    #use NEAT algorithm to build a neural network based on the pre-set configurtion
    #Create a neat.config.Config object from the configuration file
    config = neat.config.Config(neat.DefaultGenome, 
                                neat.DefaultReproduction,
                                neat.DefaultSpeciesSet, 
                                neat.DefaultStagnation,
                                config_file)
    
    #Create a neat.population.Population object using the Config object created above
    neat_pop = neat.population.Population(config)
    
    #show the summary statistics of the learning progress
    neat_pop.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    neat_pop.add_reporter(stats)
    
    #Call the run method on the Population object, giving it your fitness function and (optionally) the maximum number of generations you want NEAT to run
    neat_pop.run(main, max_gen)
    
    #get the most fit genome genome as our winner with the statistics.best_genome() function
    winner = stats.best_genome()
    
    #visualize the results
    node_names = {-1:'delta_x', -2: 'delta_y_top', -3:'delta_y_bottom', 0:'Jump or Not'}
    draw_net(config, winner, True, node_names = node_names)
    plot_stats(stats, ylog = False, view = True)
    plot_species(stats, view = True)
    
    #show the final statistics
    print('\nBest genome:\n{!s}'.format(winner))

#run the game!
config_file = 'config-feedforward.txt'
run_NEAT(config_file)
view rawRun NEAT.py hosted with ❤ by GitHub

Run NEAT
Results
Since Flappy Bird is a simple game (from a computer’s standpoint), it only takes NEAT ten generations to crack the game (Generation 0 is our first population). Let’s take a look at the species distribution and fitness improvement.



Species Distribution (left) and Fitness Improvement (right)
Note that all individuals belong to the same species because we found a solution before any topological innovation occurred. From generation 0 to generation 4, all birds almost immediately hit the ground or the upper limit. From generation 5, NEAT started to know how to keep the bird flying, but it still didn’t figure out how to get through the pipes. At generation 9, a huge breakthrough happened: a bird learned how to pass the pipes and became a skilled player you saw at the beginning of this article.

Here is the architecture of our best model. A solid line indicates an enabled connection, whereas a dashed line indicates a disabled connection. A green line indicates that the weight of the connection is positive, while a red line indicates that the weight is less than or equal to zero. The linewidth indicates the magnitude of the connection weight.


The ANN Architecture of the Best Model
The final architecture only includes an input layer and an output layer. Recall that NEAT always evolves the structure from a minimal starting point (Minimizing Dimensionality), so NEAT is able to find a low-dimensional solution efficiently. Besides, the weights of delta_y_top and delta_y_bottom are both positive, while the weight of delta_x is non-positive. The magnitude of each connection weight is pretty much the same.

Although the population is very small (5 chromosomes/generation), NEAT mastered Flappy Bird within ten iterations. It proved that NEAT is a robust technique for the efficient evolution of network structure.

Thank you so much for reading!😄 I hope you enjoy this article. Don’t forget to check out the source code for this project. Feel free to use, modify, or contribute! More interesting projects that I’ve done could be found here.

Don’t hesitate to leave your feedback in the comments section below. I’d love to share any thoughts about Pygame, GA, or NEAT with you! You can also reach me on LinkedIn. I am always up for a chat!😃

And if you like this article, please hit the clap button👏 so others may stumble upon it.

References
Efficient Evolution of Neural Network Topologies by Kenneth O. Stanley
Evolving Neural Networks through Augmenting Topologies by Kenneth O. Stanley
Efficient Evolution of Neural Networks through Complexification by Kenneth O. Stanley
NEAT-Python Documentation
NEAT: An Awesome Approach to NeuroEvolution by Hunter Heidenreich
Neuroevolution of Augmenting Topologies (NEAT) by Henry AI Labs
Emergent Tool Use from Multi-Agent Interaction by OpenAI
Deep Neuroevolution: Genetic Algorithms Are a Competitive Alternative for Training Deep Neural Networks for Reinforcement Learning by Uber AI Labs
A Newbie Guide to Pygame
PyGame Tutorials: Simple Introduction to Game Programming
YouTube Playlist for PyGame Tutorials by thenewboston
AI Plays Flappy Bird Using NEAT Python by Tech with Tim
Neural nets with Flappy and Pygame by Bluefever Software
Flappy Bird Python Tutorials For Absolute Beginners by CodeWithHarry
Artificial Intelligence
Genetic Algorithm
Flappy Bird
Game Development
Neural Networks
170


2


Analytics Vidhya
Published in Analytics Vidhya
70K Followers
·
Last published Oct 15, 2024
Analytics Vidhya is a community of Generative AI and Data Science professionals. We are building the next-gen data science ecosystem https://www.analyticsvidhya.com

Follow
Danny Zhu
Written by Danny Zhu
26 Followers
·
5 Following
Machine learning enthusiast interested in making data actionable.

Follow
More from Danny Zhu and Analytics Vidhya
Confusion Matrix, Accuracy, Precision, Recall, F1 Score
Analytics Vidhya
In

Analytics Vidhya

by

Harikrishnan N B

Confusion Matrix, Accuracy, Precision, Recall, F1 Score
Binary Classification Metric
Dec 10, 2019
1.1K
6
How to create a Python library
Analytics Vidhya
In

Analytics Vidhya

by

Kia Eisinga

How to create a Python library
Ever wanted to create a Python library, albeit for your team at work or for some open source project online? In this blog you will learn…
Jan 26, 2020
2.8K
30
The Ultimate Markdown Guide (for Jupyter Notebook)
Analytics Vidhya
In

Analytics Vidhya

by

Hannan Satopay

The Ultimate Markdown Guide (for Jupyter Notebook)
An in-depth guide for Markdown syntax usage for Jupyter Notebook
Nov 18, 2019
2.4K
13
Understanding the Mel Spectrogram
Analytics Vidhya
In

Analytics Vidhya

by

Leland Roberts

Understanding the Mel Spectrogram
(and Other Topics in Signal Processing)
Mar 5, 2020
2.2K
27
See all from Danny Zhu
See all from Analytics Vidhya
Recommended from Medium
Python is No More The King of Data Science
Stackademic
In

Stackademic

by

Abdur Rahman

Python is No More The King of Data Science
5 Reasons Why Python is Losing Its Crown

Oct 22
8.6K
34
How I Am Using a Lifetime 100% Free Server
Harendra
Harendra

How I Am Using a Lifetime 100% Free Server
Get a server with 24 GB RAM + 4 CPU + 200 GB Storage + Always Free

Oct 25
6K
84
Lists


A phone with a tweet on it describing a deepfake video of the Ukrainian president, with a labeled fake image in the background
AI Regulation
6 stories
·
635 saves

AI-generated image of a cute tiny robot in the backdrop of ChatGPT’s logo

ChatGPT
21 stories
·
896 saves



Generative AI Recommended Reading
52 stories
·
1529 saves



ChatGPT prompts
50 stories
·
2305 saves
Intro — Python Algorithms: Traveling Salesman Problem
David Liang
David Liang

Intro — Python Algorithms: Traveling Salesman Problem
The Traveling Salesman Problem (TSP) is a classic problem in computer science and operations research. It is an optimization problem that…
Jul 17
2
I used OpenAI’s o1 model to develop a trading strategy. It is DESTROYING the market
DataDrivenInvestor
In

DataDrivenInvestor

by

Austin Starks

I used OpenAI’s o1 model to develop a trading strategy. It is DESTROYING the market
It literally took one try. I was shocked.

Sep 15
6.7K
170
Jeff Bezos Says the 1-Hour Rule Makes Him Smarter. New Neuroscience Says He’s Right
Jessica Stillman
Jessica Stillman

Jeff Bezos Says the 1-Hour Rule Makes Him Smarter. New Neuroscience Says He’s Right
Jeff Bezos’s morning routine has long included the one-hour rule. New neuroscience says yours probably should too.

Oct 30
13.5K
313
Building a Knowledge Graph From Scratch Using LLMs
Towards Data Science
In

Towards Data Science

by

Cristian Leo

Building a Knowledge Graph From Scratch Using LLMs
Turn your Pandas Data Frame into a Knowledge Graph using LLMs. Build your own LLM graph-builder and QA your KG.

6d ago
511
5
See more recommendations
Help

Status

About

Careers

Press

Blog

Privacy

Terms

Text to speech

Teams